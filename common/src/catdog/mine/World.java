package catdog.mine;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

public class World {
	
	private Texture blockTex, nightBgTex, dayBgTex;
	private SpriteBatch spriteBatch;
	private Block[][] map;
	
	public static final int WIDTH = 100;
	public static final int HEIGHT = 50;
	public static final int GROUND_ALTITUDE = 25;
	
	public World() {
		blockTex = new Texture(Gdx.files.internal("data/block.png"));
		nightBgTex = new Texture(Gdx.files.internal("data/texture/bg_night.png"));
		dayBgTex = new Texture(Gdx.files.internal("data/texture/bg_day.png"));
		spriteBatch = new SpriteBatch();
		map = new Block[HEIGHT][WIDTH];
		initMap();
	}
	
	/**
	 * 맵 배치를 초기화한다.
	 */
	private void initMap() {
		calculateBlockFoundWeight();
		
		for (int i = 0; i < GROUND_ALTITUDE; i++) {
			for (int j = 0; j < WIDTH; j++) {
				//map[i][j] = new Block(ItemDB.getItem(1));
				newBlock(j, i);
			}
		}
		
		// TODO: 이것은 임시 코드임. 계단 만들기 -_-
		for (int i = GROUND_ALTITUDE; i < HEIGHT; i++) {
			//map[i][i - GROUND_ALTITUDE + 10] = new Block(ItemDB.getItem(1));
			newBlock(i - GROUND_ALTITUDE + 10, i);
		}
		
		// 임시코드. 충돌체크 테스트용
		map[GROUND_ALTITUDE][0] = new Block(ItemDB.getItem(1));
	}
	
	/**
	 * 새 블럭을 생성한다. (어떤 블럭이 생성될지는 랜덤으로)
	 * @param x
	 * @param y
	 */
	private void newBlock(int x, int y) {
		// 새로 생성될 아이템 - 기본 아이템
		Item newitem = ItemDB.getItem(1);
		
		// 해당 층에서 weight가 0이 아니면
		if(blockweightlist.get(y) != 0) {
			// 범위가 1에서 최대 weight값인 랜덤 int값 생성
			int randweight = randobj.nextInt(blockweightlist.get(y)) + 1;
			
			// 모든 블럭을 다 체크할 때까지
			for(Item item : ItemDB.getAllItems()) {
				// 해당 블럭이 나올 상황이면 아이템 대입하고 루프 종료
				int curweight = item.getFoundWeightForLevel(y);
				if(randweight <= curweight) {
					newitem = item;
					break;
				}
				// 현재 확률값만큼 빼준다
				randweight -= curweight;
				
				if(randweight <= 0) break;
			}
		}
		
		map[y][x] = new Block(newitem);
	}
	
	private ArrayList<Integer> blockweightlist;
	private Random randobj;
	
	/**
	 * 각 층마다 총 weight를 구함
	 */
	private void calculateBlockFoundWeight() {
		randobj = new Random();
		blockweightlist = new ArrayList<Integer>();
		
		Collection<Item> itemcoll = ItemDB.getAllItems();
		
		// 층마다 반복
		for(int y = 0; y < HEIGHT; y++) {
			int totalweight = 0;
			
			for(Item item : itemcoll) {
				// 자동 생성되는 블럭이 아니라면 패스
				if(!item.getAutoGenerated())
					continue;
				
				// TODO : 여기서 각 아이템이 해당 층에서 등장할 확률을 구하는 코드를
				// Item클래스의 메서드로 분리해놓기
				totalweight += item.getFoundWeightForLevel(y);
			}
			blockweightlist.add(totalweight);
		}
	}

	public void render(Viewport viewport) {
		spriteBatch.begin();
		float opacity = (1.0f + (float)Math.cos(Clock.getElapsed() * MathUtils.PI * 2 / Clock.DAY)) / 2f;
		spriteBatch.setColor(1, 1, 1, opacity);
		spriteBatch.draw(dayBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, dayBgTex.getWidth(),
				dayBgTex.getHeight(), false, false);
		spriteBatch.setColor(1, 1, 1, 1-opacity);
		spriteBatch.draw(nightBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, nightBgTex.getWidth(),
				nightBgTex.getHeight(), false, false);
		
		Vector2 pos = new Vector2();
		int x0, y0, x1, y1;
		x0 = Math.max(0, (int)viewport.startX);
		y0 = Math.max(0, (int)viewport.startY);
		x1 = Math.min(WIDTH - 1, (int)(viewport.startX + viewport.width) + 1);
		y1 = Math.min(HEIGHT - 1, (int)(viewport.startY + viewport.height));
		for (int i = y0; i <= y1; i++) {
			for (int j = x0; j <= x1; j++) {
				Block block = map[i][j]; 
				if (block != null) {
					pos.set(j, i);
					Vector2 screenPos = viewport.toScreen(pos);
					// 파괴 정도에 따라 투명도 조정
					// 블록이 알파값 0까지 투명해지면 거의 다 파괴된 블럭은 실체가 존재하는데도
					// 잘 안보이는 문제가 있어서 값을 약간 수정. (거의 다 파괴된 것도 조금은 보이도록)
					float desratio = block.getDestructionRatio();
					spriteBatch.setColor(1, 1, 1, (desratio == 1f? 0 : 1-desratio * 0.5f));
					spriteBatch.draw(block.getItem().getIconTex(), screenPos.x, screenPos.y);
				}
			}
		}
		spriteBatch.end();
	}

	/**
	 * 해당 위치의 블럭 구하기
	 * @param pos 좌표 벡터
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(Vector2 pos) {
		return getBlock((int)pos.x, (int)pos.y);
	}
	
	/**
	 * 해당 위치의 블럭 구하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(int x, int y) {
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT) {
			// 잘못된 인덱스가 아니면
			Block block = map[y][x];
			if (block != null && block.isAlive())
				return block;
		}
		return null;
	}
	
	/**
	 * 새로운 블럭을 놓을 수 있는 위치인지 확인하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return 놓을 수 있으면 true, 아니면 false
	 */
	public boolean canPutBlock(int x, int y) {
		return getBlock(x, y) == null && (
				getBlock(x - 1, y) != null || // 왼쪽
				getBlock(x + 1, y) != null || // 오른쪽
				getBlock(x, y - 1) != null || // 아래
				getBlock(x, y + 1) != null // 위
				);
	}
	
	/**
	 * 블럭을 새로 놓는다.
	 */
	public void putBlock(int x, int y, Block block) {
		map[y][x] = block;
	}
}
