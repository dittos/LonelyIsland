package catdog.mine;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;

import catdog.mine.monster.Constructor;
import catdog.mine.monster.Destructor;
import catdog.mine.monster.Ghost;
import catdog.mine.monster.Mob;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

class BlockEntry
{
	public int x, y;
	public Block block;
	
	public BlockEntry(int x, int y, Block block)
	{
		this.x = x;
		this.y = y;
		this.block = block;
	}
}

public class World {
	
	private Texture nightBgTex, dayBgTex;
	private SpriteBatch spriteBatch;
	private Block[][] map;
	private ArrayList<BlockEntry> interactable;
	private ArrayList<Mob> monsters;
	private ArrayList<ArrayList<Float>> inTime;
	private boolean lastTickWasNight = false;
	//private ArrayList<Tree> treelayer;
	
	public static final int WIDTH = 100;
	public static final int HEIGHT = 50;
	public static final int GROUND_ALTITUDE = 25;
	public static final int MARGIN = 5;
	
	public World() {
		nightBgTex = TextureDict.load("data/texture/bg_night.png");
		dayBgTex = TextureDict.load("data/texture/bg_day.png");
		spriteBatch = new SpriteBatch();
		map = new Block[HEIGHT][WIDTH];
		interactable = new ArrayList<BlockEntry>();
		monsters = new ArrayList<Mob>();
		inTime = new ArrayList<ArrayList<Float>>();
		//treelayer = new ArrayList<Tree>();
		Tree.LoadTexture();
		initMap();
	}
	
	/**
	 * 맵 배치를 초기화한다.
	 */
	private void initMap() {
		calculateBlockFoundWeight();
		
		for (int i = 0; i < GROUND_ALTITUDE; i++) {
			for (int j = MARGIN; j < WIDTH - MARGIN; j++) {
				newBlock(j, i);
			}
		}
		
		// 나무
		for(int i = 0; i < 15; i++) {
			newRandomTree();
		}
	}
	
	/**
	 * 새 블럭을 생성한다. (어떤 블럭이 생성될지는 랜덤으로)
	 * @param x
	 * @param y
	 */
	private void newBlock(int x, int y) {
		Item newitem;
		// 맨 아래층일 때는 베드락
		if(y == 0) {
			newitem = ItemDB.getItem(8);
		} else {
			// 새로 생성될 아이템 - 기본 아이템
			newitem = ItemDB.getItem(1);
			
			// 해당 층에서 weight가 0이 아니면
			if(blockweightlist.get(y) != 0) {
				// 범위가 1에서 최대 weight값인 랜덤 int값 생성
				int randweight = randobj.nextInt(blockweightlist.get(y)) + 1;
				
				// 모든 블럭을 다 체크할 때까지
				for(Item item : ItemDB.getAllItems()) {
					// 해당 블럭이 나올 상황이면 아이템 대입하고 루프 종료
					int curweight = item.getFoundWeightForLevel(y);
					if(randweight <= curweight) {
						newitem = item;
						break;
					}
					// 현재 확률값만큼 빼준다
					randweight -= curweight;
					
					if(randweight <= 0) break;
				}
			}
		}
		
		putBlock(x, y, new Block(newitem));
	}
	
	/**
	 * 적합한 위치 중에서 랜덤하게 나무 하나 생성
	 */
	private void newRandomTree() {
		int xpos;
		do
		{
			xpos = randobj.nextInt(WIDTH);
		}
		while(xpos == 0);
		// 위에서부터 훑어내려간다. 처음 발견한 블럭이 흙이면 거기에 나무 생성
		
		for(int ypos = HEIGHT - 1; ypos >= 0; ypos--) {
			if(map[ypos][xpos] != null && map[ypos][xpos].isAlive() && map[ypos][xpos-1] != null 
					&& map[ypos][xpos].getItem().getItemID() == 1) {
				Tree newtree = new Tree(new Vector2(xpos, ypos+1));
				//treelayer.add(newtree);
				map[ypos][xpos].setAttachedTree(newtree);
				break;
			}
		}
	}
	
	private ArrayList<Integer> blockweightlist;
	private Random randobj;
	
	/**
	 * 각 층마다 총 weight를 구함
	 */
	private void calculateBlockFoundWeight() {
		randobj = new Random();
		blockweightlist = new ArrayList<Integer>();
		
		Collection<Item> itemcoll = ItemDB.getAllItems();
		
		// 층마다 반복
		for(int y = 0; y < HEIGHT; y++) {
			int totalweight = 0;
			
			for(Item item : itemcoll) {
				// 자동 생성되는 블럭이 아니라면 패스
				if(!item.getAutoGenerated())
					continue;
				
				// TODO : 여기서 각 아이템이 해당 층에서 등장할 확률을 구하는 코드를
				// Item클래스의 메서드로 분리해놓기
				totalweight += item.getFoundWeightForLevel(y);
			}
			blockweightlist.add(totalweight);
		}
	}

	public void render(Viewport viewport) {
		spriteBatch.begin();
		
		// 하늘 그리기
		// 지속적으로 변하면 알아보기 힘드므로 중간에 석양이 질 때만 변하고 나머지 시간동안은 색이 유지되게
		
		float dayopacity = (float)Math.sin(Clock.getElapsed() / Clock.DAY * MathUtils.PI * 2);
		dayopacity *= 4f;
		dayopacity = Math.min(1, dayopacity);
		dayopacity = Math.max(-1, dayopacity);
		dayopacity = dayopacity / 2f + 0.5f;
		
		spriteBatch.setColor(1, 1, 1, dayopacity);
		spriteBatch.draw(dayBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, dayBgTex.getWidth(),
				dayBgTex.getHeight(), false, false);
		spriteBatch.setColor(1, 1, 1, 1-dayopacity);
		spriteBatch.draw(nightBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, nightBgTex.getWidth(),
				nightBgTex.getHeight(), false, false);
		
		// 블럭 그리기
		Vector2 pos = new Vector2();
		int x0, y0, x1, y1;
		x0 = Math.max(0, (int)viewport.startX);
		y0 = Math.max(0, (int)viewport.startY);
		x1 = Math.min(WIDTH - 1, (int)(viewport.startX + viewport.width) + 1);
		y1 = Math.min(HEIGHT - 1, (int)(viewport.startY + viewport.height));
		for (int i = y0; i <= y1; i++) {
			for (int j = x0; j <= x1; j++) {
				Block block = map[i][j]; 
				if (block != null && block.isAlive()) {
					pos.set(j, i);
					Vector2 screenPos = viewport.toScreen(pos);
					// 파괴 정도에 따라 투명도 조정
					// 블록이 알파값 0까지 투명해지면 거의 다 파괴된 블럭은 실체가 존재하는데도
					// 잘 안보이는 문제가 있어서 값을 약간 수정. (거의 다 파괴된 것도 조금은 보이도록)
					float desratio = block.getDestructionRatio();
					spriteBatch.setColor(1, 1, 1, (desratio == 1f? 0 : 1-desratio * 0.5f));
					spriteBatch.draw(block.getItem().getIconTex(), screenPos.x, screenPos.y);
					
					// 나무가 있다면 나무 그리기
					if(block.getAttachedTree() != null && block.getAttachedTree().isAlive())
						block.getAttachedTree().render(spriteBatch, viewport);
				}
			}
		}
		
		spriteBatch.end();
		
		for (Mob mob : monsters)
		{
			if(mob.isAlive())
				mob.render(viewport);
		}
	}
	
	/**
	 * 몬스터 생성
	 */
	public void genMobs(Player player) {
		int day = Clock.getDay();
		int nmob, nctor = 0, ndtor = 0, nghost = 0;
		
		// 기본 몹 (n일 째에 n마리)
		nmob = Math.min(20, day+1);
		
		// 파괴자 (4일 째부터)
		if (4 <= day)
			ndtor = (int)Math.ceil((double)(day-3) / 4.);
		
		// 생성자 (7일 째부터)
		if (7 <= day)
			nctor = (int)Math.ceil((double)(day-6) / 4.);
		
		// 유령 (12일 째부터)
		if (12 <= day)
			nghost = (int)Math.ceil((double)(day-11) / 2.);
		
			
		genMobs(Mob.class, nmob, player);
		genMobs(Constructor.class, nctor, player);
		genMobs(Destructor.class, ndtor, player);
		genMobs(Ghost.class, nghost, player);
	}
	
	public <T extends Mob> void genMobs(Class<T> mobClass, int n, Player player) {
		Mob mob;
		try {
			for (int i = 0; i < n; i++) {
				mob = mobClass.getConstructor(World.class, Player.class).newInstance(this, player);
				int randx = (randobj.nextInt(WIDTH/2)-WIDTH/4);
				randx += (randx > 0)? 10 : -10;
				randx += player.position.x;
				randx = Math.min(randx, WIDTH-MARGIN-1);
				randx = Math.max(randx, MARGIN);
				mob.position.set(randx, 30);
				monsters.add(mob);
				for(ArrayList<Float> a: inTime)
					a.add(0f);
			}
		} catch (Exception e) {
			// ignore
		}
	}
	
	public void update(float delta, Player player)
	{
		boolean isNight = Clock.isNight();
		if (lastTickWasNight != isNight) {
			if (isNight) {
				// 방금 밤이 되었음
				// 몹이 젠!!
				//Mob mob = new Mob(world, player);
				genMobs(player);
				 	
			} else {
				// 방금 아침이 되었음
				// 몹이 펑!!
				monsters.clear();
				for(ArrayList<Float> a: inTime)
					a.clear();
				// 나무 새로 만들기
				for(int i = 0; i < 7; i++) {
					newRandomTree();
				}
			}
		}
		lastTickWasNight = isNight;
		
		for(Mob mob: monsters)
		{
			if(mob.isAlive())
				mob.update(delta);
		}
			
		float elapsed = Clock.getElapsed();
		
		int i, j, ib = interactable.size(), jb = monsters.size();
		BlockEntry block;
		Mob mob;
		float lastInteract;
		
		for(i = 0; i < ib; ++ i)
		{
			block = interactable.get(i);
			for(j = 0; j < jb; ++ j)
			{
				mob = monsters.get(j);
				lastInteract = inTime.get(i)
					.get(j);
				if(Math.abs(block.x - mob.position.x) + Math.abs(block.y - mob.position.y) <= block.block.getItem().getInteractDist())
				{
					if(lastInteract == 0f)
						block.block.getItem().getInteract().boundIn(mob, monsters, block.block, block.x, block.y, 0f);
					else
						block.block.getItem().getInteract().boundIn(mob, monsters, block.block, block.x, block.y, elapsed - lastInteract);
					inTime.get(i).set(j, elapsed);
				}
				else
				{
					if(lastInteract != 0f)
					{
						block.block.getItem().getInteract().boundOut(mob, monsters, block.block, block.x, block.y, elapsed - lastInteract);
						inTime.get(i).set(j, 0f);
					}
				}
			}
		}
	}

	/**
	 * 해당 위치의 블럭 구하기
	 * @param pos 좌표 벡터
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(Vector2 pos) {
		return getBlock((int)pos.x, (int)pos.y);
	}
	
	/**
	 * 해당 위치의 블럭 구하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(int x, int y) {
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT) {
			// 잘못된 인덱스가 아니면
			Block block = map[y][x];
			if (block != null && block.isAlive())
				return block;
		}
		return null;
	}
	
	/**
	 * 새로운 블럭을 놓을 수 있는 위치인지 확인하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return 놓을 수 있으면 true, 아니면 false
	 */
	public boolean canPutBlock(int x, int y) {
		// 정상 범위일 때
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT)
			return getBlock(x, y) == null && (
					getBlock(x - 1, y) != null || // 왼쪽
					getBlock(x + 1, y) != null || // 오른쪽
					getBlock(x, y - 1) != null || // 아래
					getBlock(x, y + 1) != null);
		else
			return false;
	}
	
	/**
	 * 블럭을 새로 놓는다.
	 */
	public void putBlock(int x, int y, Block block) {
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT) {
			// 잘못된 인덱스가 아니면
			if(block.getItem().getInteract() != null)
			{
				interactable.add(new BlockEntry(x, y, block));
				ArrayList<Float> a = new ArrayList<Float>(monsters.size());
				for(int i = monsters.size(); i > 0; -- i)
					a.add(0f);
				inTime.add(a);
			}
			map[y][x] = block;
		}
	}
}
