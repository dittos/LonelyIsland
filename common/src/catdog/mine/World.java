package catdog.mine;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Random;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Vector2;

class BlockEntry
{
	public int x, y;
	public Block block;
	
	public BlockEntry(int x, int y, Block block)
	{
		this.x = x;
		this.y = y;
		this.block = block;
	}
}

public class World {
	
	private Texture blockTex, nightBgTex, dayBgTex;
	private SpriteBatch spriteBatch;
	private Block[][] map;
	private ArrayList<BlockEntry> interactable;
	//private ArrayList<Tree> treelayer;
	
	public static final int WIDTH = 100;
	public static final int HEIGHT = 50;
	public static final int GROUND_ALTITUDE = 25;
	
	public World() {
		blockTex = new Texture(Gdx.files.internal("data/block.png"));
		nightBgTex = new Texture(Gdx.files.internal("data/texture/bg_night.png"));
		dayBgTex = new Texture(Gdx.files.internal("data/texture/bg_day.png"));
		spriteBatch = new SpriteBatch();
		map = new Block[HEIGHT][WIDTH];
		interactable = new ArrayList<BlockEntry>();
		//treelayer = new ArrayList<Tree>();
		Tree.LoadTexture();
		initMap();
	}
	
	/**
	 * 맵 배치를 초기화한다.
	 */
	private void initMap() {
		calculateBlockFoundWeight();
		
		// TODO: Interactable
		
		for (int i = 0; i < GROUND_ALTITUDE; i++) {
			for (int j = 0; j < WIDTH; j++) {
				//map[i][j] = new Block(ItemDB.getItem(1));
				newBlock(j, i);
			}
		}
		
		// TODO: 이것은 임시 코드임. 계단 만들기 -_-
		for (int i = GROUND_ALTITUDE; i < HEIGHT; i++) {
			//map[i][i - GROUND_ALTITUDE + 10] = new Block(ItemDB.getItem(1));
			newBlock(i - GROUND_ALTITUDE + 10, i);
		}
		
		// 임시코드. 충돌체크 테스트용
		map[GROUND_ALTITUDE][0] = new Block(ItemDB.getItem(1));
		
		
		// 나무
		// 일단 아무렇게나...
		//treelayer.add(new Tree(new Vector2(3, 25)));
		for(int i = 0; i < 20; i++) {
			newRandomTree();
		}
	}
	
	/**
	 * 새 블럭을 생성한다. (어떤 블럭이 생성될지는 랜덤으로)
	 * @param x
	 * @param y
	 */
	private void newBlock(int x, int y) {
		Item newitem;
		// 맨 아래층일 때는 베드락
		if(y == 0) {
			newitem = ItemDB.getItem(8);
		} else {
			// 새로 생성될 아이템 - 기본 아이템
			newitem = ItemDB.getItem(1);
			
			// 해당 층에서 weight가 0이 아니면
			if(blockweightlist.get(y) != 0) {
				// 범위가 1에서 최대 weight값인 랜덤 int값 생성
				int randweight = randobj.nextInt(blockweightlist.get(y)) + 1;
				
				// 모든 블럭을 다 체크할 때까지
				for(Item item : ItemDB.getAllItems()) {
					// 해당 블럭이 나올 상황이면 아이템 대입하고 루프 종료
					int curweight = item.getFoundWeightForLevel(y);
					if(randweight <= curweight) {
						newitem = item;
						break;
					}
					// 현재 확률값만큼 빼준다
					randweight -= curweight;
					
					if(randweight <= 0) break;
				}
			}
		}
		
		putBlock(x, y, new Block(newitem));
	}
	
	/**
	 * 적합한 위치 중에서 랜덤하게 나무 하나 생성
	 */
	private void newRandomTree() {
		int xpos = randobj.nextInt(WIDTH);
		// 위에서부터 훑어내려간다. 처음 발견한 블럭이 흙이면 거기에 나무 생성
		
		for(int ypos = HEIGHT - 1; ypos >= 0; ypos--) {
			if(map[ypos][xpos] != null && map[ypos][xpos].isAlive() 
					&& map[ypos][xpos].getItem().getItemID() == 1) {
				Tree newtree = new Tree(new Vector2(xpos, ypos+1));
				//treelayer.add(newtree);
				map[ypos][xpos].setAttachedTree(newtree);
				break;
			}
		}
	}
	
	private ArrayList<Integer> blockweightlist;
	private Random randobj;
	
	/**
	 * 각 층마다 총 weight를 구함
	 */
	private void calculateBlockFoundWeight() {
		randobj = new Random();
		blockweightlist = new ArrayList<Integer>();
		
		Collection<Item> itemcoll = ItemDB.getAllItems();
		
		// 층마다 반복
		for(int y = 0; y < HEIGHT; y++) {
			int totalweight = 0;
			
			for(Item item : itemcoll) {
				// 자동 생성되는 블럭이 아니라면 패스
				if(!item.getAutoGenerated())
					continue;
				
				// TODO : 여기서 각 아이템이 해당 층에서 등장할 확률을 구하는 코드를
				// Item클래스의 메서드로 분리해놓기
				totalweight += item.getFoundWeightForLevel(y);
			}
			blockweightlist.add(totalweight);
		}
	}

	public void render(Viewport viewport) {
		spriteBatch.begin();
		
		// 하늘 그리기
		// 지속적으로 변하면 알아보기 힘드므로 중간에 석양이 질 때만 변하고 나머지 시간동안은 색이 유지되게
		
		float dayopacity = (float)Math.sin(Clock.getElapsed() / Clock.DAY * MathUtils.PI * 2);
		dayopacity *= 4f;
		dayopacity = Math.min(1, dayopacity);
		dayopacity = Math.max(-1, dayopacity);
		dayopacity = dayopacity / 2f + 0.5f;
		
		spriteBatch.setColor(1, 1, 1, dayopacity);
		spriteBatch.draw(dayBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, dayBgTex.getWidth(),
				dayBgTex.getHeight(), false, false);
		spriteBatch.setColor(1, 1, 1, 1-dayopacity);
		spriteBatch.draw(nightBgTex, 0, 0, viewport.screenWidth,
				viewport.screenHeight, 0, 0, nightBgTex.getWidth(),
				nightBgTex.getHeight(), false, false);
		
		// 블럭 그리기
		Vector2 pos = new Vector2();
		int x0, y0, x1, y1;
		x0 = Math.max(0, (int)viewport.startX);
		y0 = Math.max(0, (int)viewport.startY);
		x1 = Math.min(WIDTH - 1, (int)(viewport.startX + viewport.width) + 1);
		y1 = Math.min(HEIGHT - 1, (int)(viewport.startY + viewport.height));
		for (int i = y0; i <= y1; i++) {
			for (int j = x0; j <= x1; j++) {
				Block block = map[i][j]; 
				if (block != null && block.isAlive()) {
					pos.set(j, i);
					Vector2 screenPos = viewport.toScreen(pos);
					// 파괴 정도에 따라 투명도 조정
					// 블록이 알파값 0까지 투명해지면 거의 다 파괴된 블럭은 실체가 존재하는데도
					// 잘 안보이는 문제가 있어서 값을 약간 수정. (거의 다 파괴된 것도 조금은 보이도록)
					float desratio = block.getDestructionRatio();
					spriteBatch.setColor(1, 1, 1, (desratio == 1f? 0 : 1-desratio * 0.5f));
					spriteBatch.draw(block.getItem().getIconTex(), screenPos.x, screenPos.y);
					
					// 나무가 있다면 나무 그리기
					if(block.getAttachedTree() != null && block.getAttachedTree().isAlive())
						block.getAttachedTree().render(spriteBatch, viewport);
				}
			}
		}
		
		spriteBatch.end();
	}

	/**
	 * 해당 위치의 블럭 구하기
	 * @param pos 좌표 벡터
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(Vector2 pos) {
		return getBlock((int)pos.x, (int)pos.y);
	}
	
	/**
	 * 해당 위치의 블럭 구하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return Block 오브젝트 (없을 경우 null)
	 */
	public Block getBlock(int x, int y) {
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT) {
			// 잘못된 인덱스가 아니면
			Block block = map[y][x];
			if (block != null && block.isAlive())
				return block;
		}
		return null;
	}
	
	/**
	 * 새로운 블럭을 놓을 수 있는 위치인지 확인하기
	 * @param x x좌표
	 * @param y y좌표
	 * @return 놓을 수 있으면 true, 아니면 false
	 */
	public boolean canPutBlock(int x, int y) {
		return getBlock(x, y) == null && (
				getBlock(x - 1, y) != null || // 왼쪽
				getBlock(x + 1, y) != null || // 오른쪽
				getBlock(x, y - 1) != null || // 아래
				getBlock(x, y + 1) != null // 위
				);
	}
	
	/**
	 * 블럭을 새로 놓는다.
	 */
	public void putBlock(int x, int y, Block block) {
		if (0 <= x && x < WIDTH && 0 <= y && y < HEIGHT) {
			// 잘못된 인덱스가 아니면
			if(block.getItem().getInteract() != null)
				interactable.add(new BlockEntry(x, y, block));
			map[y][x] = block;
		}
	}
}
